# 第二章  面试需要的基础知识

## 2.2.1  C++

* 对 C++ 关键字的理解程度

  在 C++ 中，有哪4个与类型转换相关的关键字？这些关键字各有什么特点，应该在什么场合下使用？

（待完成）



* 面试题1：赋值运算符函数

  注意点：

  把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（\*this），只有返回一个引用，才可以允许连续赋值。

  需将传入的参数类型声明为 常量引用 ，否则若是传入实例，那么从形参到实参会调用一次复制构造函数。引用参数前加const关键字，确保在函数内不会改变传入的实例的状态。





## 2.2.2  C sharp

- struct 和 class 区别：

  C++中，在没有标明成员函数或者成员变量的访问权限级别，struct默认public，class默认private；

  C\#中，默认都是private的，区别在于struct定义的是值类型，值类型的实例在栈上分配内存，class定义的是引用类型，引用类型的实例在堆上分配内存。

  ​

- C\#的反射，应用程序域（AppDomain），代理？

（待完成）



- 面试题2：单例模式 Singleton

  加锁是一个非常耗时的操作，在没有必要的时候应该尽量避免。

  c#中的静态构造函数能确保只调用一次，在调用构造函数时初始化静态变量 

  ​



## 2.3.1  数组

- 使用动态数组时要尽量减少改变数组容量大小的次数
- 在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针！！！（不管形参是否声明为数组）







## 2.3.2  字符串

- 为了节省内存，C/C++ 会把常量字符串放到单独的一个内存区域，常量字符串在内存中只有一个拷贝。

- C#中，System.String 中的内容是不能改变的，一旦试图改变String的内容，就会产生一个新的实例。改变后的值只能通过返回值得到。连续多次修改时，每一次修改都会产生一个临时对象，开销太大会影响效率

- C#中，试图把一个常量字符串赋值给一个 String 实例，也不是把 String 的内容改成赋值的字符串，而是生成一个新的 String 实例。

- 面试题 4：替换空格

  合并两个数组（包括字符串）时，若从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，那么可以考虑从后往前复制，这样能减少移动的次数，从而提高效率。





## 2.3.3  链表

- 基于递归的代码虽然看起来简洁，但是当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。因此，显式用栈基于循环实现的代码的鲁棒性要好一些。

  ​

## 2.3.4  树

- 前序遍历，中序遍历，后序遍历，三种遍历的递归实现和循环实现
- 宽度优先遍历
- 二叉搜索树，左子树结点总是小于或等于根结点，而右子树总是大于或等于根结点。可以再平均O（log n）的时间内根据数值在二叉搜索树中找到一个结点。
- 最大堆中根结点的值最大，在最小堆中根结点的值最小。
- 红黑树把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短距离的两倍。C++ 的 STL 中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。



- 面试题6：在中序遍历中找到根结点的值，++ rootInorder是否会越界？



## 2.3.5 栈和队列

- 操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。
- 树的宽度优先遍历算法中，在遍历某一层树的结点时，把结点的子结点放到一个队列里，以备下一层结点的遍历。



## 2.4.1 查找和排序

- 顺序查找、二分查找、哈希查找、二叉树排序查找
- 要求在排序的数组（或部分排序的数组）中查找一个数字或者统计某个数字出现的次数，可以尝试用二分查找算法
- 哈希表能够在O（1）时间查找某一元素，是效率最高的查找方式，但缺点是需要额外的空间来实现哈希表。
- 插入排序、冒泡排序、归并排序、快速排序  额外空间小号，平均时间复杂度，最差时间复杂度。
- 虽然快速排序总体的平均效率是最好的，但也不是任何时候都是最优的算法。若数组本身已经排好序了，而每一轮排序的时候都是以最后一个数字作为比较的标准，此时快速排序的效率只有O（n^2）为快排最差情况。



- 面试题8：旋转数组的最小数字

  - 在排序的数组中可以利用二分查找法实现O（logn）的查找

  - 特例：排序数组本身，仍然是数组的一个旋转。因此，需要将indexMid初始化为index1。

    ​	

## 2.4.2  递归和循环

- 若面试官没有特别的要求，应尽量多采用递归。
- 递归是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址、临时变量。往栈里压入数据和弹出数据都需要时间，因此递归实现的效率不如循环。
- 递归中有可能很多计算都是重复，从而对性能带来很大的负面影响。递归的本质是把一个问题分解为两个或多个小问题，若小问题存在相互重叠的部分，就会存在重复的计算。
- 递归可能会引起严重的问题：调用栈溢出。递归调用的层级太多时，就会超出栈的容量，从而导致调用栈溢出。



## 2.4.3  位运算

- 位运算总共只有5种运算：与，或，异或，左移，右移。
- 右移时，若数字是一个无符号数值，则用0填补最左边的n位；若数字是一个有符号数值，则用数字的符号位填补最左边的n位。
- 除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位云算法代替除法。
- 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边的一个1变成0。很多二进制的问题都可以用这个思路解决。