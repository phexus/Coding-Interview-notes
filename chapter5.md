# 第五章  优化时间和空间效率

## 5.2  时间效率

- C/C++ 程序员要养成采用引用（或指针）传递复杂类型参数的习惯。值传递的方式。从形参到实参会产生一次复制操作，应尽量避免。

- C\#做多次字符串拼接操作时，不要多次用 String 的 + 运算符来拼接字符串，这样会产生很多 String 临时实例，造成时间和空间的浪费。更好的办法是用 String Builder 的 Append 方法来完成字符串的拼接。

## 面试题29  数组中出现次数超过一半的数字

- 数组在参数传递的时候退化为指针，需要考虑这个指针可能为 NULL 的情况。

- 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。

## 面试题30  最小的 k 个数

- 在最大堆中，根结点的值总是大于它的子树中任意结点的值。

- 红黑树通过把结点分为红、黑两种颜色并根据一些规则确保树在一定程度上是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要 O（logk）时间。

- STL中 set 和 multiset 都是基于红黑树实现的。

## 面试题31  连续子数组的最大和

- 通常用递归的方式分析动态规划的问题，但最终都会基于循环去编码。

## 面试题32  从 1 到 n 整数中 1 出现的次数 *（需进一步研究）

- 本题较难，每次去掉最高位做递归，递归的次数和位数相同，一个数字 n 有 O（logn）位！

## 面试题33  把数组排成最小的数

- 把两个 int 型的整数拼接起来得到的数字可能会超出 int 型数字能够表达的范围，从而导致数字溢出。可以用字符串表示数字，解决大数问题。本题用到了 spritf（strNumbers[i], "%d", number[i[）函数。

## 5.3  时间效率与空间效率的平衡

- “以时间换空间”的策略并不一定都是可行的，需要具体问题具体分析。

## 面试题35  第一个只出现一次的字符

- 题目换成汉字，如何解决？？？Unicode字符编码从 0000 到 FFFF

- 需要判断多个字符是不是在某个字符串里出现过或者统计多个字符在某个字符串中出现的次数，可以考虑基于数组创建一个简单的哈希表。这样可以用很小的空间消耗换来时间效率的提升。

## 面试题36  数组中的逆序对

- 归并排序！！归并排序的时间复杂度是 O（nlogn） 需要进一步理解！！！

## 本章小结

- 降低时间复杂度的方法：1. 改用更高效的算法；2. 空间换时间

- 以空间换时间并不一定都是可行的方案；要注意需要的辅助空间的大小，消耗太多的内存可能得不偿失。